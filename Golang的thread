先熟悉golang的threads的特性。

首先看一段code:

func main() {
	time.Sleep(1 * time.Second)
	println("started")
	go periodic()
}

func periodic() {
	for {
		println("tick")
		time.Sleep(1 * time.Second)
	}
}

输出的结果将是”started“。或者是”started“ ”tick“。可能性有多种。
这是因为main func中并不是按照串行的形式运行code的 ***
所以main可能等不到periodic运行，就结束了这个进程。

解决这个问题，有许多种办法。
其一就是加上time.sleep。给periodic一些时间。

如下;
func main() {
	time.Sleep(1 * time.Second)
	println("started")
	go periodic()
	time.Sleep(5 * time.Second) // wait for a while so we can observe what ticker does
}

func periodic() {
	for {
		println("tick")
		time.Sleep(1 * time.Second)
	}
}

这样就能正常的运行出periodic中的println("tick")。

如果现在再加一段code，println另外一些文字，且同时要保持顺序。
例如想输出：
started
tick
tick
tick
tick
tick
canceled
这段文字。
错误code:

func main() {
	time.Sleep(1 * time.Second)
	println("started")
	go periodic()
	time.Sleep(5 * time.Second) // wait for a while so we can observe what ticker does
	println("cancelled")
	time.Sleep(3 * time.Second) // observe no output
}

func periodic() {
	for {
		println("tick")
		time.Sleep(1 * time.Second)
	}
}

这里输出的结果不能保证cancelled就在tick的后面的。
如果要保证cancelled就在tick后面，可以这样写。

var done bool
var mu sync.Mutex

func main() {
	time.Sleep(1 * time.Second)
	println("started")
	go periodic()
	time.Sleep(5 * time.Second) // wait for a while so we can observe what ticker does
	mu.Lock()//不能忘记加锁，心里一定要记住，有数据改动的地方就要加锁
	done = true
	mu.Unlock()//不能忘记解锁
	println("cancelled")
	time.Sleep(3 * time.Second) // observe no output
}

func periodic() {
	for {
		println("tick")
		time.Sleep(1 * time.Second)
		mu.Lock()
		if done {
			return
		}
		mu.Unlock()
	}
}

这样可以通过一个锁的机制来确保Goroutines的运行中数据不会出现***

******************************************************

Goroutines的理解
code:

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 7; i++ {
		wg.Add(1)
		go func() {
			sendRPC(i)
			wg.Done()
		}()
	}
	wg.Wait()
}

func sendRPC(i int) {
	println(i)
}
这里就有明显的一个bug，就是go fun子进程时，你会发现输入的i可能已经发生变化了。从而导致输出的i不是按照我们需要的顺序输出来的。

改进方法为:

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(x int) {
			sendRPC(x)
			wg.Done()
		}(i)
	}
	wg.Wait()
}

func sendRPC(i int) {
	println(i)
}
这样就可以达到合理的效果了。
这里一定要明白的是sync.WaitGroup的作用是:
A WaitGroup waits for a collection of goroutines to finish. 
The main goroutine calls Add to set the number of goroutines to wait for. 
Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.
主要作用是等待全部的goroutines完成，同时主goroutines会添加一些子goroutines，且同时等待他们完成。这里的wait可以block，当所有的goroutines完成时。


**********************************************
聊一聊锁，锁的主要作用是在goroutines中要对数据进行read,write的时候确保数据***的作用，防止出现一些****的作用
举个例子code:
func main() {
	counter := 0
	for i := 0; i < 1000; i++ {
		go func() {
			counter = counter + 1
		}()
	}

	time.Sleep(1 * time.Second)
	println(counter)
}

如果没有锁的话，就会出现counter的println的结果可能是或大或小的结果。
心中必须要牢记一条，有数据的read和write就要加锁
修改如下
code:
func main() {
	counter := 0
	var mu sync.Mutex
	for i := 0; i < 1000; i++ {
		go func() {
			mu.Lock()
			defer mu.Unlock()
			counter = counter + 1
		}()
	}

	time.Sleep(1 * time.Second)
	mu.Lock()
	println(counter)
	mu.Unlock()
}
这样就可以合理的打出1000这个结果了
